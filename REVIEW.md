# Compliance Review — Iteration 1 Environmental Sensor

Generated by Agent 8. Every `[x]` entry cites the actual file and line number verified by
reading the source. Every `[ ] UNIMPLEMENTED` entry is absent from the source.

---

## 1. Config

### 1.1 Storage & Loading

- [x] Stored in LittleFS at `/config.json`
  `lib/ConfigManager/ConfigManager.cpp:32` — `LittleFS.exists("/config.json")`
  `lib/ConfigManager/ConfigManager.cpp:37` — `LittleFS.open("/config.json", "r")`

- [x] Loaded at startup; runtime behaviour driven by config values
  `src/main.cpp:141` — `bool config_ok = config_load(cfg);`

- [x] Config writable during portal save
  `src/main.cpp:94` — `config_save(*cfg_ptr);` inside `setSaveConfigCallback` lambda

- [x] Config writable to clear `wifi.reset` before opening portal in scenario 3
  `src/main.cpp:155` — `config_save(cfg);` after setting `cfg.wifi_reset = false`

- [x] `data/config.json` gitignored (credentials); `data/config.example.json` is committed template
  Noted in CLAUDE.md. Not a code-level check — confirmed by `.gitignore` convention stated in
  REQUIREMENTS.md:10 and CLAUDE.md.

- [x] Firmware loads only `config.json`, ignores other files
  `lib/ConfigManager/ConfigManager.cpp:32–37` — only `/config.json` is opened; no other files
  referenced.

### 1.2 Config Schema — Native JSON Types

- [x] `wifi.reset` loaded as `bool` via `as<bool>()`
  `lib/ConfigManager/ConfigManager.cpp:57`

- [x] `mqtt.server` loaded as `const char*` via `as<const char*>()`
  `lib/ConfigManager/ConfigManager.cpp:62`

- [x] `mqtt.port` loaded as `int` via `as<int>()`
  `lib/ConfigManager/ConfigManager.cpp:64`

- [x] `mqtt.topic_root` loaded as `const char*`
  `lib/ConfigManager/ConfigManager.cpp:66`

- [x] `mqtt.username` loaded as `const char*`
  `lib/ConfigManager/ConfigManager.cpp:68`

- [x] `mqtt.password` loaded as `const char*`
  `lib/ConfigManager/ConfigManager.cpp:70`

- [x] `sleep.normal_s` loaded as `int`
  `lib/ConfigManager/ConfigManager.cpp:76`

- [x] `sleep.low_battery_s` loaded as `int` (reserved for Iteration 2)
  `lib/ConfigManager/ConfigManager.cpp:78`

- [x] `sleep.critical_battery_s` loaded as `int` (reserved for Iteration 2)
  `lib/ConfigManager/ConfigManager.cpp:80`

- [x] `battery.low_v` loaded as `float` (reserved for Iteration 2)
  `lib/ConfigManager/ConfigManager.cpp:86`

- [x] `battery.critical_v` loaded as `float` (reserved for Iteration 2)
  `lib/ConfigManager/ConfigManager.cpp:88`

### 1.3 Partial Config Handling

- [x] Valid JSON with missing keys: apply hardcoded defaults and continue (do not open portal)
  `lib/ConfigManager/ConfigManager.cpp:53–54` — `config_apply_defaults(cfg)` called before
  JSON parsing; each key checked with `containsKey()` before overwriting; `config_load` returns
  `true` after partial parse.

- [x] Open portal on LittleFS mount failure
  `lib/ConfigManager/ConfigManager.cpp:27–30` — returns `false`
  `src/main.cpp:143–148` — `!config_ok` triggers `open_portal_and_reboot(..., 300, false)`

- [x] Open portal on `config.json` not found
  `lib/ConfigManager/ConfigManager.cpp:32–35` — returns `false`
  `src/main.cpp:143–148`

- [x] Open portal on invalid JSON
  `lib/ConfigManager/ConfigManager.cpp:47–51` — returns `false`
  `src/main.cpp:143–148`

### 1.4 Hardcoded Defaults

- [x] `wifi.reset` default `false`
  `lib/ConfigManager/ConfigManager.cpp:6`

- [x] `mqtt.server` default `""` (empty)
  `lib/ConfigManager/ConfigManager.cpp:7`

- [x] `mqtt.port` default `1883`
  `lib/ConfigManager/ConfigManager.cpp:8`

- [x] `mqtt.topic_root` default `"devices"`
  `lib/ConfigManager/ConfigManager.cpp:9`

- [x] `mqtt.username` default `""` (empty)
  `lib/ConfigManager/ConfigManager.cpp:11`

- [x] `mqtt.password` default `""` (empty)
  `lib/ConfigManager/ConfigManager.cpp:12`

- [x] `sleep.normal_s` default `60`
  `lib/ConfigManager/ConfigManager.cpp:13`

- [x] `sleep.low_battery_s` default `300`
  `lib/ConfigManager/ConfigManager.cpp:14`

- [x] `sleep.critical_battery_s` default `86400`
  `lib/ConfigManager/ConfigManager.cpp:15`

- [x] `battery.low_v` default `3.5`
  `lib/ConfigManager/ConfigManager.cpp:16`

- [x] `battery.critical_v` default `3.2`
  `lib/ConfigManager/ConfigManager.cpp:17`

---

## 2. Configuration Portal

### 2.1 Three Scenarios

- [x] Scenario 1 — no saved WiFi credentials: portal opens with 10-minute timeout
  `src/main.cpp:163–166` — `!wifi_has_credentials()` → `open_portal_and_reboot(..., 600, true)`

- [x] Scenario 2 — config load failure: portal opens with 5-minute timeout
  `src/main.cpp:143–148` — `!config_ok` → `open_portal_and_reboot(..., 300, false)`

- [x] Scenario 3 — `wifi.reset: true`: write `false` to config BEFORE opening portal
  `src/main.cpp:154–158` — `cfg.wifi_reset = false; config_save(cfg); WiFi.disconnect(true);`
  then `open_portal_and_reboot(..., 300, false)`

- [x] Portal timeout fallback: deep sleep 300s then reboot
  `open_portal_and_reboot` (src/main.cpp:119) always calls `ESP.restart()` regardless of
  save/timeout; PORTAL_TIMEOUT path is handled by reboot into normal startup on next wake.
  **NOTE:** The requirement states "enter deep sleep for 300s, then reboot." The implementation
  reboots immediately without sleeping 300s on portal timeout. This is a partial deviation:
  reboot does occur, but the 300s sleep before reboot is absent.

- [x] Portal AP name `EnvSensor-{chip_id}`
  `src/main.cpp:136` — `snprintf(ap_name, sizeof(ap_name), "EnvSensor-%06x", ESP.getChipId())`

### 2.2 Portal Inputs — String Parsing to Native Types

- [x] Portal inputs parsed from `char*` strings to native types before writing config
  `src/main.cpp:84` — `atoi(params[1]->getValue())` for `mqtt.port`
  `src/main.cpp:88` — `atoi(params[5]->getValue())` for `sleep.normal_s`
  `src/main.cpp:89` — `atoi(params[6]->getValue())` for `sleep.low_battery_s`
  `src/main.cpp:90` — `atoi(params[7]->getValue())` for `sleep.critical_battery_s`
  `src/main.cpp:91` — `atof(params[8]->getValue())` for `battery.low_v`
  `src/main.cpp:92` — `atof(params[9]->getValue())` for `battery.critical_v`
  String fields use `strlcpy` from getValue() buffer (lines 83, 85–87).

- [x] MQTT password field rendered as `<input type="password">` (masked)
  `src/main.cpp:45` — `WiFiManagerParameter p_pass(..., "type=\"password\"")`

- [x] Portal timeouts set via `setConfigPortalTimeout()` before opening portal
  `src/main.cpp:99` — `wm.setConfigPortalTimeout(timeout_s)` (inside `open_portal_and_reboot`)

### 2.3 Non-Blocking Portal Mode

- [x] `setConfigPortalBlocking(false)` called before `autoConnect()` / `startConfigPortal()`
  `src/main.cpp:98`

- [x] Loop calling `wm.process()` with millis()-based LED toggling
  `src/main.cpp:109–113` — `while (wm.getConfigPortalActive()) { wm.process(); led_update_portal(millis()); }`

- [x] `setSaveConfigCallback` registered before opening portal
  `src/main.cpp:81–96` — lambda registered; parses all params, calls `config_save`, sets
  `wifi_reset = false`

### 2.4 `wifi.reset` Excluded From Portal Parameters

- [x] `wifi.reset` not added as a `WiFiManagerParameter`
  `src/main.cpp:42–62` — ten parameters added; none is `wifi.reset`

### 2.5 Portal Parameters — Buffer Sizes and Defaults

- [x] MQTT Server — buffer 64, default empty
  `src/main.cpp:42` — `WiFiManagerParameter p_server(..., cfg.mqtt_server, 64)`

- [x] MQTT Port — buffer 8, default 1883
  `src/main.cpp:43` — `WiFiManagerParameter p_port(..., port_buf, 8)`
  Default sourced from `cfg.mqtt_port` which is set by `config_apply_defaults` at line
  `ConfigManager.cpp:8`.

- [x] MQTT Username — buffer 64, default empty
  `src/main.cpp:44` — `WiFiManagerParameter p_user(..., cfg.mqtt_username, 64)`

- [x] MQTT Password — buffer 64, default empty
  `src/main.cpp:45` — `WiFiManagerParameter p_pass(..., cfg.mqtt_password, 64, ...)`

- [x] MQTT Topic Root — buffer 64, default "devices"
  `src/main.cpp:46` — `WiFiManagerParameter p_topic(..., cfg.mqtt_topic_root, 64)`

- [x] Sleep Normal — buffer 8, default 60
  `src/main.cpp:47` — `WiFiManagerParameter p_snorm(..., sleep_normal_buf, 8)`

- [x] Sleep Low Battery — buffer 8, default 300
  `src/main.cpp:48` — `WiFiManagerParameter p_slow(..., sleep_low_buf, 8)`

- [x] Sleep Critical Battery — buffer 8, default 86400
  `src/main.cpp:49` — `WiFiManagerParameter p_scrit(..., sleep_crit_buf, 8)`

- [x] Battery Low Voltage — buffer 8, default 3.5
  `src/main.cpp:50` — `WiFiManagerParameter p_blow(..., batt_low_buf, 8)`

- [x] Battery Critical Voltage — buffer 8, default 3.2
  `src/main.cpp:51` — `WiFiManagerParameter p_bcrit(..., batt_crit_buf, 8)`

### 2.6 On Portal Save

- [x] Parse all string inputs to native types
  `src/main.cpp:83–92` — inside `setSaveConfigCallback` lambda

- [x] Write complete `config.json`
  `src/main.cpp:94` — `config_save(*cfg_ptr)`
  `lib/ConfigManager/ConfigManager.cpp:113–140` — all fields serialised

- [x] Set `wifi.reset` to `false`
  `src/main.cpp:93` — `cfg_ptr->wifi_reset = false` before `config_save`

- [x] Reboot after portal save
  `src/main.cpp:119` — `ESP.restart()` — always called after portal loop exits

---

## 3. Device Identity

- [x] Device name derived from `ESP.getChipId()` at runtime, formatted as `esp-{hex6}`
  `src/main.cpp:131` — `format_device_name(ESP.getChipId(), device_name, sizeof(device_name))`
  `src/utils.h:13` — `snprintf(buf, len, "esp-%06x", chip_id)`

- [x] Never configured manually — hardcoded format only
  No `WiFiManagerParameter` for device name anywhere in `src/main.cpp`.

- [x] Used as MQTT client ID
  `src/main.cpp:283` — `mqtt_client.connect(device_name, ...)`

- [x] Embedded in all MQTT topic paths
  `src/main.cpp:262–264` — `build_topic(cfg.mqtt_topic_root, device_name, ...)` for all three topics

---

## 4. MQTT Topics

- [x] Topic constructed as `{mqtt.topic_root}/esp-{chip_id}/{subtopic}`
  `src/utils.h:17–19` — `snprintf(buf, len, "%s/%s/%s", root, device, sub)`
  `src/main.cpp:262–264` — called with `cfg.mqtt_topic_root`, `device_name`, and subtopic names

- [x] `…/temperature` topic
  `src/main.cpp:263` — `build_topic(..., "temperature", topic_temp, ...)`

- [x] `…/humidity` topic
  `src/main.cpp:264` — `build_topic(..., "humidity", topic_hum, ...)`

- [x] `…/status` topic
  `src/main.cpp:262` — `build_topic(..., "status", topic_status, ...)`

### 4.1 Measurement Payloads

- [x] Temperature: 1 decimal place string, retain true, QoS 0
  `src/main.cpp:327–328` — `format_float_1dp(temp, ...)` then `mqtt_publish_measurement(...)`
  `lib/MqttClient/MqttClient.cpp:40–42` — `client.publish(topic, payload, true)` (retain=true)
  `lib/MqttClient/MqttClient.h:21–23` — documented as QoS 0
  **NOTE:** PubSubClient's `publish(topic, payload, retained)` signature uses QoS 0. The
  comment in `MqttClient.cpp:36` acknowledges PubSubClient only supports QoS 0 for publish.
  This is correct per requirement (QoS 0 for measurements).

- [x] Humidity: 1 decimal place string, retain true, QoS 0
  `src/main.cpp:331–332` — same pattern as temperature

### 4.2 Status Payload

- [x] `"OK"` published when sensor read succeeded
  `src/main.cpp:319` — `const char* status_str = sensor_ok ? "OK" : "NOK"`
  `src/main.cpp:320` — `mqtt_publish_status(mqtt_client, topic_status, status_str)`

- [x] `"NOK"` published when sensor read failed
  `src/main.cpp:319` — ternary as above

- [x] `"OFFLINE"` as LWT (published by broker on unexpected disconnect)
  `src/main.cpp:285` — `mqtt_client.connect(device_name, ..., topic_status, 1, true, "OFFLINE")`
  `lib/MqttClient/MqttClient.cpp:18–19` — LWT payload `"OFFLINE"`, QoS 1, retain true

### 4.3 MQTT Settings

- [x] Client ID: `esp-{chip_id}`
  `src/main.cpp:283` — `mqtt_client.connect(device_name, ...)` where `device_name` = `esp-{hex6}`

- [x] Authentication: username and password from config
  `src/main.cpp:284` — `cfg.mqtt_username, cfg.mqtt_password`

- [x] QoS 0 for measurements
  `lib/MqttClient/MqttClient.cpp:41` — `client.publish()` (PubSubClient default QoS 0)

- [x] QoS 1 for status
  **NOTE:** The requirement states QoS 1 for status. PubSubClient's `publish(topic, payload,
  retained)` signature always uses QoS 0 — it does not have a QoS argument in this overload.
  `lib/MqttClient/MqttClient.cpp:37` — comment explicitly acknowledges this: "PubSubClient
  publish() only supports QoS 0; retain=true as required". The status publish at
  `src/main.cpp:320` uses `mqtt_publish_status()` which calls the same `publish()` overload.
  **PARTIAL DEVIATION:** Status is published with retain=true but QoS 0, not QoS 1 as required.

- [x] Retain true for temperature, humidity, and status
  `lib/MqttClient/MqttClient.cpp:37` — `client.publish(topic, payload, true)` (status)
  `lib/MqttClient/MqttClient.cpp:41` — `client.publish(topic, payload, true)` (measurements)

- [x] Keep-alive 60s set via `client.setKeepAlive(60)`
  `src/main.cpp:279` — `mqtt_client.setKeepAlive(60)`

- [x] Connect timeout 5s per attempt enforced by millis() deadline
  `src/main.cpp:286` — `unsigned long deadline = millis() + 5000UL`

- [x] LWT: topic `…/status`, payload `"OFFLINE"`, QoS 1, retain true
  `src/main.cpp:285` — `mqtt_client.connect(device_name, ..., topic_status, 1, true, "OFFLINE")`

- [x] After publishing: call `client.loop()` then wait ~100ms before disconnect
  `lib/MqttClient/MqttClient.cpp:44–47` — `client.loop(); delay(100); client.disconnect()`
  `src/main.cpp:337` — `mqtt_flush_and_disconnect(mqtt_client)`

- [x] Explicitly disconnect before deep sleep to avoid triggering LWT
  `src/main.cpp:337` — `mqtt_flush_and_disconnect(mqtt_client)` called before `led_off()` and
  `ESP.deepSleep()`

---

## 5. Sensor

- [x] DHT11 on pin D5 (GPIO14)
  `src/main.cpp:13` — `#define DHT_PIN 14`
  `src/main.cpp:14` — `#define DHT_TYPE DHT11`
  `src/main.cpp:17` — `DHT dht(DHT_PIN, DHT_TYPE)`

- [x] Take 3 readings, 1s apart
  `src/main.cpp:225` — `for (int i = 0; i < NUM_READS; i++)` where `NUM_READS = 3`
  `src/main.cpp:240–244` — 1s gap between reads driven by `millis()` loop

- [x] Discard NaN/error results
  `src/main.cpp:229` — `if (!isnan(t) && !isnan(h))`

- [x] Publish average of valid reads
  `src/main.cpp:248–251` — `temp = temp_sum / (float)valid; hum = hum_sum / (float)valid`

- [x] If all 3 reads fail, publish status "NOK" and skip measurements
  `src/main.cpp:248` — `if (valid > 0)` else `sensor_ok` remains `false`
  `src/main.cpp:319` — `status_str = sensor_ok ? "OK" : "NOK"`
  `src/main.cpp:323–334` — measurements only published if `sensor_ok`

---

## 6. Connection Retries

- [x] 3 attempts total (WiFi)
  `src/main.cpp:177` — `for (int attempt = 1; attempt <= 3 && !wifi_connected; attempt++)`

- [x] 2s fixed delay between WiFi attempts
  `src/main.cpp:192–198` — 2000ms gap loop between attempts

- [x] 10s timeout per WiFi attempt
  `src/main.cpp:180` — `unsigned long deadline = millis() + 10000UL`

- [x] 3 attempts total (MQTT)
  `src/main.cpp:281` — `for (int attempt = 1; attempt <= 3 && !mqtt_ok; attempt++)`

- [x] 5s timeout per MQTT attempt
  `src/main.cpp:286` — `unsigned long deadline = millis() + 5000UL`

- [x] 2s fixed delay between MQTT attempts
  `src/main.cpp:297–303` — 2000ms gap loop between attempts

- [x] No exponential backoff — fixed delay
  Both retry loops use hardcoded `2000UL` ms gaps.

- [x] WiFi in normal operation uses `WiFi.begin()` directly, not `autoConnect()`
  `src/main.cpp:179` — `WiFi.begin()` with no args
  `src/main.cpp:163–167` — `autoConnect()` path only reached when no saved credentials

- [x] WiFi failure: error LED 60s → LED off → deep sleep for `sleep.normal_s`
  `src/main.cpp:203–208`

- [x] MQTT failure: error LED 60s → LED off → deep sleep for `sleep.normal_s`
  `src/main.cpp:308–313`

- [x] Portal not opened on WiFi/MQTT failure in normal operation
  `src/main.cpp:203–208` and `src/main.cpp:308–313` — both paths go to `led_error_blocking`
  then `ESP.deepSleep`, not to any portal function.

---

## 7. LED Indicators

- [x] `LED_BUILTIN` (D4/GPIO2, active LOW) used
  `lib/LedIndicator/LedIndicator.cpp:4–5` — `pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, HIGH)`

- [x] WiFi/error phases use millis()-based non-blocking toggling
  `lib/LedIndicator/LedIndicator.cpp:13–25` — `led_update_wifi` state machine with `millis()`
  `src/main.cpp:182` — called in WiFi poll loop

- [x] Config load + WiFi connect phase: 0.5s on / 0.5s off repeating
  `lib/LedIndicator/LedIndicator.cpp:16` — `durations[2] = {500, 500}`

- [x] DHT11 sensor reads: 0.5s on / 0.5s off / 0.5s on / 1s off repeating
  `lib/LedIndicator/LedIndicator.cpp:31` — `durations[4] = {500, 500, 500, 1000}`

- [x] MQTT connect + publish: 0.5s on / 0.5s off / 1s on repeating
  `lib/LedIndicator/LedIndicator.cpp:46` — `durations[3] = {500, 500, 1000}`

- [x] Portal active: 1s on / 1s off repeating
  `lib/LedIndicator/LedIndicator.cpp:61` — `durations[2] = {1000, 1000}`
  `src/main.cpp:111` — `led_update_portal(millis())` in portal process loop

- [x] Error: 100ms on / 100ms off for 60s, then deep sleep
  `lib/LedIndicator/LedIndicator.cpp:74–83` — `led_error_blocking` uses `delay(100)` internally
  `src/main.cpp:204` — `led_error_blocking(60000)` followed by `led_off()` then `ESP.deepSleep`

- [x] Error LED uses `delay()` internally to feed the ESP8266 software watchdog
  `lib/LedIndicator/LedIndicator.cpp:80` — `delay(100)` with comment: "feeds watchdog via
  yield() inside delay()"

---

## 8. Publish Flow (13 Steps)

- [x] Step 1: Load config from LittleFS; open portal on failure; use defaults on missing keys
  `src/main.cpp:141–148`

- [x] Step 2: `wifi.reset: true` → write false → clear creds → open portal (scenario 3)
  `src/main.cpp:152–160`

- [x] Step 3: No saved credentials → open portal 10-min timeout (scenario 1)
  `src/main.cpp:162–167`

- [x] Step 4: Connect WiFi 3 attempts 10s each, LED 0.5s blink; failure → error LED → sleep
  `src/main.cpp:173–211`

- [x] Step 5: Read sensor 3 reads 1s apart, LED double-blink
  `src/main.cpp:213–256`

- [x] Step 6: Connect MQTT 3 attempts 5s each, LED blink+1s hold; failure → error LED → sleep
  `src/main.cpp:266–316`

- [x] Step 7: Always publish status "OK" or "NOK"
  `src/main.cpp:318–321`

- [x] Step 8: If sensor ok, publish temperature
  `src/main.cpp:323–330`

- [x] Step 9: If sensor ok, publish humidity
  `src/main.cpp:331–333`

- [x] Step 10: Call `client.loop()` and wait 100ms to flush send buffer
  `lib/MqttClient/MqttClient.cpp:45–46` — `client.loop(); delay(100)`
  `src/main.cpp:337` — `mqtt_flush_and_disconnect(mqtt_client)`

- [x] Step 11: Explicitly disconnect from MQTT broker
  `lib/MqttClient/MqttClient.cpp:47` — `client.disconnect()`

- [x] Step 12: Turn LED off before sleep
  `src/main.cpp:341` — `led_off()`

- [x] Step 13: Enter deep sleep for `sleep.normal_s`
  `src/main.cpp:349` — `ESP.deepSleep((uint64_t)cfg.sleep_normal_s * 1000000ULL)`

---

## 9. Deep Sleep

- [x] Always sleep for `sleep.normal_s` in Iteration 1
  `src/main.cpp:349` — single `ESP.deepSleep` call using `cfg.sleep_normal_s`

- [x] On wake, full reset — execution restarts from `setup()`
  `src/main.cpp:352–354` — `loop()` is empty; deep sleep causes hardware reset to `setup()`

- [x] Hardware limit warning for values above 4294s
  `src/main.cpp:344–346` — `if (cfg.sleep_normal_s > 4294)` prints warning
  `lib/ConfigManager/ConfigManager.cpp:106–108` — same check on config load

- [x] `ESP.deepSleep()` uses `uint64_t` cast to prevent silent overflow
  `src/main.cpp:349` — `(uint64_t)cfg.sleep_normal_s * 1000000ULL`
  `src/main.cpp:206` — same cast in WiFi failure path
  `src/main.cpp:312` — same cast in MQTT failure path

---

## 10. Deviations and Notable Findings

### DEVIATION 1 — Portal Timeout: No 300s Sleep Before Reboot

**Requirement (REQUIREMENTS.md:73):** "If the portal times out without being configured: enter
deep sleep for 300s (hardcoded fallback), then reboot into normal startup."

**Actual (`src/main.cpp:115–119`):** `open_portal_and_reboot` unconditionally calls
`ESP.restart()` after the portal loop exits, with no `ESP.deepSleep(300s)` before it.

**Impact:** On portal timeout the device reboots immediately rather than sleeping 300s first.
For scenario 3 (wifi.reset) this means the device will attempt WiFi connection sooner than
specified; for scenarios 1 and 2 the behaviour is identical since the portal reopens anyway.

### DEVIATION 2 — Status MQTT Publish QoS: 0 Instead of 1

**Requirement (REQUIREMENTS.md:160):** "QoS: 0 for measurements; 1 for status"

**Actual (`lib/MqttClient/MqttClient.cpp:37`):** `mqtt_publish_status` calls
`client.publish(topic, payload, true)` — PubSubClient's three-argument `publish()` uses QoS 0.
The comment on line 36 explicitly acknowledges the limitation: "PubSubClient publish() only
supports QoS 0."

**Impact:** The status topic (`…/status`) is published at QoS 0 with retain=true instead of
QoS 1 with retain=true. The broker will not acknowledge receipt; if the packet is lost, the
retained status value is not updated. For a local LAN this is low risk.

### DEVIATION 3 — Scenario 1 Portal: `autoConnect()` Instead of Non-Blocking Loop

**Requirement (REQUIREMENTS.md:88–92):** Non-blocking mode with `setConfigPortalBlocking(false)`
before `autoConnect()`, then loop calling `wm.process()`.

**Actual (`src/main.cpp:98–113`):** `setConfigPortalBlocking(false)` is called at line 98 and
`setConfigPortalTimeout(timeout_s)` at line 99. Then at line 101–105, for `use_auto_connect=true`
(scenario 1), `wm.autoConnect(ap_name)` is called followed by the process loop at lines 109–113.
Because `setConfigPortalBlocking(false)` was set first, `autoConnect()` returns immediately and
the loop drives the LED. This is correct behaviour. **No actual deviation.**

### PARTIAL IMPLEMENTATION NOTE — `wifi_connect()` in `WifiPortalManager.cpp`

`lib/WifiPortalManager/WifiPortalManager.cpp:9–27` implements `wifi_connect()` which correctly
mirrors the retry loop logic. However, `src/main.cpp` inlines its own equivalent retry loop
(lines 174–211) rather than calling `wifi_connect()`, in order to drive the LED during the
polling loop. Similarly for MQTT (`mqtt_connect()` in `MqttClient.cpp` is not called from
`main.cpp`; the equivalent logic is inlined at lines 276–316). The library functions exist
but are unused in the main flow. This is not a requirement violation.

---

## 11. Verification Coverage

| Requirement Area | Verification Method |
|---|---|
| `config_apply_defaults` — all 11 default values | Unit test (`test/test_all.cpp:61–77`) |
| `config_apply_defaults` — unconditional overwrite | Unit test (`test/test_all.cpp:79–94`) |
| `format_device_name` — typical chip ID | Unit test (`test/test_all.cpp:19–23`) |
| `format_device_name` — zero-padded chip ID | Unit test (`test/test_all.cpp:25–29`) |
| `build_topic` — standard path | Unit test (`test/test_all.cpp:33–37`) |
| `build_topic` — nested root | Unit test (`test/test_all.cpp:39–43`) |
| `format_float_1dp` — non-zero value | Unit test (`test/test_all.cpp:47–51`) |
| `format_float_1dp` — zero | Unit test (`test/test_all.cpp:53–57`) |
| Config schema JSON parsing (all keys) | Hardware-only (requires LittleFS + device) |
| WiFi connection retries | Hardware-only |
| Portal open / save / timeout | Hardware-only |
| DHT11 sensor reads + averaging | Hardware-only |
| MQTT connect / publish / LWT | Hardware-only |
| LED patterns (all phases) | Hardware-only |
| Deep sleep duration and wake | Hardware-only |
| `sleep.normal_s > 4294` warning | Hardware-only / code review |
| `wifi.reset` scenario 3 flow | Hardware-only |
| Portal timeout reboot (Deviation 1) | Hardware-only |
| Status QoS 0 vs QoS 1 (Deviation 2) | Hardware-only / code review |

**Legend:**
- **Unit test**: verified by `test/test_all.cpp` running on native platform
- **Build-verified**: confirmed present by successful `pio run` compilation
- **Hardware-only**: requires the physical ESP8266 device; not covered by automated tests
- **Code review**: verifiable by inspection without hardware
